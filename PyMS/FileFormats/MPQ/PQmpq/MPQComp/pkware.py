
# Python port of SComp by Ladislav Zezula, which is an implementation of:
#   PKWARE Data Compression Library for Win32
#   Copyright 1989-1995 PKWARE Inc.  All Rights Reserved
#   Patent No. 5,051,745
#   PKWARE Data Compression Library Reg. U.S. Pat. and Tm. Off.
#   Version 1.11

from .....Utilities.PyMSError import  PyMSError

import struct

from typing import TextIO

class Tables:
	# char
	dist_bits = (
		0x02, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x06,
		0x06, 0x06, 0x06, 0x06, 0x06, 0x06, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07,
		0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08
	)

	# char
	dist_code = (
		0x03, 0x0D, 0x05, 0x19, 0x09, 0x11, 0x01, 0x3E, 0x1E, 0x2E, 0x0E, 0x36, 0x16, 0x26, 0x06, 0x3A,
		0x1A, 0x2A, 0x0A, 0x32, 0x12, 0x22, 0x42, 0x02, 0x7C, 0x3C, 0x5C, 0x1C, 0x6C, 0x2C, 0x4C, 0x0C,
		0x74, 0x34, 0x54, 0x14, 0x64, 0x24, 0x44, 0x04, 0x78, 0x38, 0x58, 0x18, 0x68, 0x28, 0x48, 0x08,
		0xF0, 0x70, 0xB0, 0x30, 0xD0, 0x50, 0x90, 0x10, 0xE0, 0x60, 0xA0, 0x20, 0xC0, 0x40, 0x80, 0x00
	)

	# char
	ex_len_bits = (
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
	)

	# short
	len_base = (
		0x0000, 0x0001, 0x0002, 0x0003, 0x0004, 0x0005, 0x0006, 0x0007,
		0x0008, 0x000A, 0x000E, 0x0016, 0x0026, 0x0046, 0x0086, 0x0106
	)

	# char
	len_bits = (
		0x03, 0x02, 0x03, 0x03, 0x04, 0x04, 0x04, 0x05, 0x05, 0x05, 0x05, 0x06, 0x06, 0x06, 0x07, 0x07
	)

	# char
	len_code = (
		0x05, 0x03, 0x01, 0x06, 0x0A, 0x02, 0x0C, 0x14, 0x04, 0x18, 0x08, 0x30, 0x10, 0x20, 0x40, 0x00
	)

	# char
	ch_bits_asc = [
		0x0B, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x08, 0x07, 0x0C, 0x0C, 0x07, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0D, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x04, 0x0A, 0x08, 0x0C, 0x0A, 0x0C, 0x0A, 0x08, 0x07, 0x07, 0x08, 0x09, 0x07, 0x06, 0x07, 0x08,
		0x07, 0x06, 0x07, 0x07, 0x07, 0x07, 0x08, 0x07, 0x07, 0x08, 0x08, 0x0C, 0x0B, 0x07, 0x09, 0x0B,
		0x0C, 0x06, 0x07, 0x06, 0x06, 0x05, 0x07, 0x08, 0x08, 0x06, 0x0B, 0x09, 0x06, 0x07, 0x06, 0x06,
		0x07, 0x0B, 0x06, 0x06, 0x06, 0x07, 0x09, 0x08, 0x09, 0x09, 0x0B, 0x08, 0x0B, 0x09, 0x0C, 0x08,
		0x0C, 0x05, 0x06, 0x06, 0x06, 0x05, 0x06, 0x06, 0x06, 0x05, 0x0B, 0x07, 0x05, 0x06, 0x05, 0x05,
		0x06, 0x0A, 0x05, 0x05, 0x05, 0x05, 0x08, 0x07, 0x08, 0x08, 0x0A, 0x0B, 0x0B, 0x0C, 0x0C, 0x0C,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C,
		0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0C, 0x0D,
		0x0D, 0x0D, 0x0C, 0x0C, 0x0C, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D, 0x0D
	]

	# short
	ch_code_asc = (
		0x0490, 0x0FE0, 0x07E0, 0x0BE0, 0x03E0, 0x0DE0, 0x05E0, 0x09E0,
		0x01E0, 0x00B8, 0x0062, 0x0EE0, 0x06E0, 0x0022, 0x0AE0, 0x02E0,
		0x0CE0, 0x04E0, 0x08E0, 0x00E0, 0x0F60, 0x0760, 0x0B60, 0x0360,
		0x0D60, 0x0560, 0x1240, 0x0960, 0x0160, 0x0E60, 0x0660, 0x0A60,
		0x000F, 0x0250, 0x0038, 0x0260, 0x0050, 0x0C60, 0x0390, 0x00D8,
		0x0042, 0x0002, 0x0058, 0x01B0, 0x007C, 0x0029, 0x003C, 0x0098,
		0x005C, 0x0009, 0x001C, 0x006C, 0x002C, 0x004C, 0x0018, 0x000C,
		0x0074, 0x00E8, 0x0068, 0x0460, 0x0090, 0x0034, 0x00B0, 0x0710,
		0x0860, 0x0031, 0x0054, 0x0011, 0x0021, 0x0017, 0x0014, 0x00A8,
		0x0028, 0x0001, 0x0310, 0x0130, 0x003E, 0x0064, 0x001E, 0x002E,
		0x0024, 0x0510, 0x000E, 0x0036, 0x0016, 0x0044, 0x0030, 0x00C8,
		0x01D0, 0x00D0, 0x0110, 0x0048, 0x0610, 0x0150, 0x0060, 0x0088,
		0x0FA0, 0x0007, 0x0026, 0x0006, 0x003A, 0x001B, 0x001A, 0x002A,
		0x000A, 0x000B, 0x0210, 0x0004, 0x0013, 0x0032, 0x0003, 0x001D,
		0x0012, 0x0190, 0x000D, 0x0015, 0x0005, 0x0019, 0x0008, 0x0078,
		0x00F0, 0x0070, 0x0290, 0x0410, 0x0010, 0x07A0, 0x0BA0, 0x03A0,
		0x0240, 0x1C40, 0x0C40, 0x1440, 0x0440, 0x1840, 0x0840, 0x1040,
		0x0040, 0x1F80, 0x0F80, 0x1780, 0x0780, 0x1B80, 0x0B80, 0x1380,
		0x0380, 0x1D80, 0x0D80, 0x1580, 0x0580, 0x1980, 0x0980, 0x1180,
		0x0180, 0x1E80, 0x0E80, 0x1680, 0x0680, 0x1A80, 0x0A80, 0x1280,
		0x0280, 0x1C80, 0x0C80, 0x1480, 0x0480, 0x1880, 0x0880, 0x1080,
		0x0080, 0x1F00, 0x0F00, 0x1700, 0x0700, 0x1B00, 0x0B00, 0x1300,
		0x0DA0, 0x05A0, 0x09A0, 0x01A0, 0x0EA0, 0x06A0, 0x0AA0, 0x02A0,
		0x0CA0, 0x04A0, 0x08A0, 0x00A0, 0x0F20, 0x0720, 0x0B20, 0x0320,
		0x0D20, 0x0520, 0x0920, 0x0120, 0x0E20, 0x0620, 0x0A20, 0x0220,
		0x0C20, 0x0420, 0x0820, 0x0020, 0x0FC0, 0x07C0, 0x0BC0, 0x03C0,
		0x0DC0, 0x05C0, 0x09C0, 0x01C0, 0x0EC0, 0x06C0, 0x0AC0, 0x02C0,
		0x0CC0, 0x04C0, 0x08C0, 0x00C0, 0x0F40, 0x0740, 0x0B40, 0x0340,
		0x0300, 0x0D40, 0x1D00, 0x0D00, 0x1500, 0x0540, 0x0500, 0x1900,
		0x0900, 0x0940, 0x1100, 0x0100, 0x1E00, 0x0E00, 0x0140, 0x1600,
		0x0600, 0x1A00, 0x0E40, 0x0640, 0x0A40, 0x0A00, 0x1200, 0x0200,
		0x1C00, 0x0C00, 0x1400, 0x0400, 0x1800, 0x0800, 0x1000, 0x0000  
	)

	# asc tables
	offsGenerated = False
	offs2C34 = () # type: tuple[int, ...]
	offs2D34 = () # type: tuple[int, ...]
	offs2E34 = () # type: tuple[int, ...]
	offs2EB4 = () # type: tuple[int, ...]

	# decode tables
	positionsGenerated = False
	position1 = () # type: tuple[int, ...]
	position2 = () # type: tuple[int, ...]

	@staticmethod
	def gen_asc_tables(): # type: () -> None
		if Tables.offsGenerated:
			return
		offs2C34 = [0] * 0x100
		offs2D34 = [0] * 0x100
		offs2E34 = [0] * 0x80
		offs2EB4 = [0] * 0x100
		for index in range(0xFF, -1, -1):
			bits = Tables.ch_bits_asc[index]
			acc = Tables.ch_code_asc[index]
			if bits <= 8:
				add = (1 << bits)
				for pos in range(acc, 0x100, add):
					offs2C34[pos] = index
			elif (acc & 0xFF) != 0:
				offs2C34[acc & 0xFF] = 0xFF
				if acc & 0x3F:
					bits -= 4
					Tables.ch_bits_asc[index] = bits
					add = (1 << bits)
					acc >>= 4
					for pos in range(acc, 0x100, add):
						offs2D34[pos] = index
				else:
					bits -= 6
					Tables.ch_bits_asc[index] = bits
					add = (1 << bits)
					acc >>= 6
					for pos in range(acc, 0x80, add):
						offs2E34[pos] = index
			else:
				bits -= 8
				Tables.ch_bits_asc[index] = bits
				add = (1 << bits)
				acc >>= 8
				for pos in range(acc, 0x100, add):
					offs2EB4[pos] = index
		Tables.offsGenerated = True
		Tables.offs2C34 = tuple(offs2C34)
		Tables.offs2D34 = tuple(offs2D34)
		Tables.offs2E34 = tuple(offs2E34)
		Tables.offs2EB4 = tuple(offs2EB4)

	@staticmethod
	def gen_decode_tables(): # type: () -> None
		if Tables.positionsGenerated:
			return
		def gen_decode_table(count, bits_table, code_table):
			positions = [0] * 0x100
			for index in range(count-1, -1, -1):
				code = code_table[index]
				bits = 1 << bits_table[index]
				for pos in range(code, 0x100, bits):
					positions[pos] = index
			return positions
		Tables.positionsGenerated = True
		Tables.position1 = gen_decode_table(0x40, Tables.dist_bits, Tables.dist_code)
		Tables.position2 = gen_decode_table(0x10, Tables.len_bits, Tables.len_code)

class CompType:
	binary = 0
	ascii  = 1

class Lit:
	# We are complete decompresssing
	done = 0
	# The value is a decompressed byte
	byte = 1
	# The value is how many bytes to copy from existing decompressed data
	copy = 2

def implode(data): # type: (bytes) -> bytes
	return b''

BYTE = struct.Struct('<B')

class InputExhaustedException(Exception):
	pass

class Explode(object):
	DEBUG: TextIO

	comp_type: int
	dsize_bits: int
	bit_buff: int

	def __init__(self, data): # type: (bytes) -> None
		if Explode.DEBUG is None:
			Explode.DEBUG = open('p_debug_explode.txt', 'w')

		self.data = data

		self.comp_type, self.dsize_bits, self.bit_buff = tuple(int(b) for b in struct.unpack('<3B', data[:3]))
		self.offset = 3

		if 4 > self.dsize_bits or self.dsize_bits > 6:
			raise PyMSError('Explode', "Invalid dictionary size (got %d, need 4, 5 or 6)" % self.dsize_bits)
		if self.comp_type != CompType.binary:
			if self.comp_type != CompType.ascii:
				raise PyMSError('Explode', "Invalid compression type (got %d, need either 0 or 1)" % self.comp_type)
			Tables.gen_asc_tables()
		Tables.gen_decode_tables()

		self.dsize_mask = 0xFFFF >> (0x10 - self.dsize_bits)
		self.extra_bits = 0

	def read_byte(self): # type: () -> int
		if self.offset == len(self.data):
			raise InputExhaustedException()
		byte = self.data[self.offset]
		self.offset += 1
		Explode.DEBUG.write("  pos: %d\n" % self.offset)
		return byte

	def waste_bits(self, bits): # type: (int) -> None
		Explode.DEBUG.write("waste: %d\n" % bits)
		if bits <= self.extra_bits:
			self.extra_bits -= bits
			self.bit_buff >>= bits
			Explode.DEBUG.write("1buff: %d extra: %d\n" % (self.bit_buff, self.extra_bits))
		else:
			self.bit_buff >>= self.extra_bits
			self.bit_buff |= (self.read_byte() << 8)
			self.bit_buff >>= (bits - self.extra_bits)
			self.extra_bits = (self.extra_bits - bits) + 8
			Explode.DEBUG.write("2buff: %d extra: %d\n" % (self.bit_buff, self.extra_bits))

	def decode_lit(self): # type: () -> tuple[int, int | None]
		# If current bit is set, return that we will copy X bytes, otherwise return X as the raw byte
		lit_copy = self.bit_buff & 1
		self.waste_bits(1)
		if lit_copy:
			value = Tables.position2[self.bit_buff & 0xFF]
			self.waste_bits(Tables.len_bits[value])
			bits = Tables.ex_len_bits[value]
			if bits != 0:
				value2 = (self.bit_buff & ((1 << bits) - 1))
				try:
					self.waste_bits(bits)
				except PyMSError:
					if (value + value2) != 0x10E:
						raise
				value = Tables.len_base[value] + value2
				if value == 0x205:
					return (Lit.done, None)
			return (Lit.copy, value + 2)
		
		if self.comp_type == CompType.binary:
			value = (self.bit_buff & 0xFF)
			self.waste_bits(8)
			return (Lit.byte, value)

		if self.bit_buff & 0xFF:
			value = Tables.offs2C34[self.bit_buff & 0xFF]
			if value == 0xFF:
				if self.bit_buff & 0x3F:
					self.waste_bits(4)
					value = Tables.offs2D34[self.bit_buff & 0xFF]
				else:
					self.waste_bits(6)
					value = Tables.offs2E34[self.bit_buff & 0x7F]
		else:
			self.waste_bits(8)
			value = Tables.offs2EB4[self.bit_buff & 0xFF]
		self.waste_bits(Tables.ch_bits_asc[value])

		return (Lit.byte, value)

	def decode_dist(self, length): # type: (int) -> int
		pos = Tables.position1[self.bit_buff & 0xFF]
		skip = Tables.dist_bits[pos]
		self.waste_bits(skip)
		if length == 2:
			pos = (pos << 2) | (self.bit_buff & 0x03)
			self.waste_bits(2)
		else:
			pos = (pos << self.dsize_bits) | (self.bit_buff & self.dsize_mask)
			self.waste_bits(self.dsize_bits)
		return pos + 1

	def expand(self): # type: () -> bytes
		Explode.DEBUG.write(' size: %d\n' % len(self.data))
		Explode.DEBUG.write('====\n')
		decompressed = b''
		try:
			while True:
				lit, value = self.decode_lit()
				if lit == Lit.done:
					break
				assert value is not None
				Explode.DEBUG.write('  lit: %d %d\n' % (lit, value))
				if lit == Lit.copy:
					move_back = self.decode_dist(value)
					Explode.DEBUG.write(' dist: %d\n' % move_back)
					Explode.DEBUG.write('write:')
					# `move_back` can be less than `value`, which means it will end up copying from the copied data. For example:
					# If `decompressed == \x00\x01\x02\x03`, `move_back == 2`, and `value` == 4, the result would be `\x00\x01\x02\x03\x02\x03\x02\x03`
					while value > 0:
						copy_size = min(move_back, value)
						for c in decompressed[-move_back:-move_back + copy_size or None]:
							Explode.DEBUG.write(' %d' % c)
						decompressed += decompressed[-move_back:-move_back + copy_size or None]
						value -= copy_size
					Explode.DEBUG.write('\n')
				else:
					Explode.DEBUG.write('write: %d\n' % value)
					decompressed += BYTE.pack(value)
		except InputExhaustedException:
			pass
		except:
			raise
		return decompressed

def explode(data): # type: (bytes) -> bytes
	if len(data) < 4:
		raise PyMSError('Explode', "Not enough data to explode (got %d bytes, need at least 4)" % len(data))
	info = Explode(data)
	return info.expand()
